package lib

import lib.Runtime

/*
 * Thin façade over the provisioning configuration runtime.
 *
 * Scripts call these helpers to avoid referencing the legacy __gnash_* shims
 * directly. During the current Gnash → Bash transition the real behaviour is
 * provided by the transpiled Bash runtime (see scripts/runtime/config-runtime.sh).
 */

public def reload() {
  Runtime.invoke("Config.reload", [])
}

public def stepEnabled(stepKey) {
  return Runtime.invoke("Config.stepEnabled", [stepKey]) == true
}

public def stepValue(stepKey, field) {
  return Runtime.call("Config.stepValue", [stepKey, field])
}

public def stepList(stepKey, field) {
  return Runtime.call("Config.stepList", [stepKey, field])
}

public def boolean(stepKey, field, defaultValue) {
  result = Runtime.call("Config.boolean", [stepKey, field, defaultValue])
  if (!result) {
    return defaultValue
  }
  text = result.toString().toLowerCase()
  if (text == "true") {
    return true
  }
  if (text == "false") {
    return false
  }
  return defaultValue
}

public def string(stepKey, field, defaultValue) {
  value = Runtime.call("Config.string", [stepKey, field, defaultValue])
  if (!value) {
    return defaultValue
  }
  return value.toString()
}

public def get(path) {
  return Runtime.call("Config.get", [path])
}

public def getOrDefault(path, defaultValue) {
  value = Runtime.call("Config.getOrDefault", [path, defaultValue])
  if (!value) {
    return defaultValue
  }
  return value
}

public def isTrue(path) {
  return Runtime.invoke("Config.isTrue", [path]) == true
}

public def isTrueOrDefault(path, defaultValue) {
  result = Runtime.call("Config.isTrueOrDefault", [path, defaultValue])
  if (!result) {
    return defaultValue
  }
  text = result.toString().toLowerCase()
  if (text == "true") {
    return true
  }
  if (text == "false") {
    return false
  }
  return defaultValue
}

public def list(path) {
  return Runtime.call("Config.list", [path])
}
